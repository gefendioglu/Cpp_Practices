
## OBJECT ORIENTED PROGRAMMING (OOP)

/----------------------------------------------
/----------------------------------------------

- **Class** : A class is an abstract definition of something that has data members and member class functions. 

- **Interface** : The public class member functions provide an interface that is the only access to the data structures contained in the class.

- **Constructor** : Creating an object is called constructing the object. Part of the process involves invoking a "constructor" in the class. The constructor initializes the state of the object. 

- **Destructor** :  In C++ a member function called the destructor is invoked to clean up an object’s state.

- **Inheritance** : It allows a class to be defined as a modified or more specialized version of another class.

- **Polymorphism** : A core concept of OOP, enabled by overriding, is runtime selection of which definition of a class member function should be executed based on the class of the object.

/----------------------------------------------
/----------------------------------------------

- **Example** : Class Implementation 
  - A class definition for Member, which is a pair of integers that represents the x and y values of a Member in a Cartesian coordinate plane:

#include <iostream>
#include <string>

class Member {
public:
	Member() = default;
	Member(int x, int y) :mx{ x }, my{ y } {}
	Member(const Member& other) {
		std::cout << "Copy constructor called " << "\n";
		mx = other.getX();
		my = other.getY();
	}

	Member& operator= (const Member& Member) {
		std::cout << "Assignment operator called " << "\n";
		return *this;
	}
	
	// getter functions
	int getX() const { return mx; }
	int getY() const { return my; }

	//setter functions
	void setX(const int& x) { this->mx = x; }
	void setY(const int& y) { this->my = y; }

	// other functions
	Member* relativeTo(int dx, int dy) {
		return new Member(mx + dx, my + dy);
	}

	std::string toString() {
		std::string str;
		str.push_back('(');
		str.push_back(mx);
		str.push_back(',');
		str.push_back((char)my);
		str.push_back(')');
		return str;
	}

private:
	int mx, my;

};

int main()
{
	Member cartesian(10, 20);
	std::cout << "mx : " << cartesian.getX() << "\n"; // mx : 10
	std::cout << "my : " << cartesian.getY() << "\n"; // my : 20

	Member* ptr = new Member(30, 40);
	std::cout << "mx : " << ptr->getX() << "\n"; // mx : 30
	std::cout << "my : " << ptr->getY() << "\n"; // my : 40

	Member* p1 = cartesian.relativeTo(5, -5);
	std::cout << "p1 : " << p1->toString() << "\n"; // NOT OK !!! To Be Controlled !!!
}

/----------------------------------------------
/----------------------------------------------

- **Example** : C++ Object Model

class Thing {}; 

class Thing {
public:
    Thing();                        // default constructor
    Thing(const Thing&);            // copy ctor
    Thing& operator=(const Thing&); // copy-assignment
    Thing(Thing&&);                 // move ctor
    Thing& operator=(Thing&&);      // move-assignment
	~Thing();                       // dtor
};  

/----------------------------------------------
/----------------------------------------------

- **Example** : C++ Object Model 
  - All the functions in class/struct contain implicit this pointer as the first argument using to access all non-static data members
  - Static data members are not part of class/struct. Because it usually resides in a data segment of memory layout.
  - The size of the following struct is 4 (because of int type non-static data member). Because of using implicit this pointer as function parameter.

struct foo{
	int m_var;
public:
	void print(){
		std::cout << m_var << "\n";
	}
};

Interpreted as the following: 
struct foo{
    int m_var;
};

void foo::print(foo *this){
    std::cout.operator<<(this->m_var).operator<<(std::endl);
}

/----------------------------------------------
/----------------------------------------------

- **Example**: Memory Layout of an Object With Virtual Function & Static Data Member
  - all non-static data members got the space into the stack with the same order of their declaration
  - static data member got the space into the data segment of memory.
  - static functions go into the text segment
  - For virtual keyword, the compiler automatically inserts pointer(vptr) to a virtual table into the object memory representation.

class MyClass {
public:
    MyClass() {}
    virtual ~MyClass() {}
    virtual void printAll() {}
    void printInt() {}
    void printFloat() {}
    static void printCount() {}
private:
	int         ival;
    float       fval;
    static int  count;
};


Memory Layout: 
stack :
/----------------------------------------------
int MyClass::ival 
float MyClass::fval 
MyClass::_vptr    

data segment:
/----------------------------------------------
static int MyClass::count 

text segment:
/----------------------------------------------
MyClass::MyClass()     
MyClass::~MyClass()
MyClass::printAll()
MyClass::printInt()
MyClass::printFloat()
static MyClass::printCount()

/----------------------------------------------
/----------------------------------------------

- **Example**: Memory Layout of C++ Object With Inheritance

class Base {
public:
	Base() {}
	virtual ~Base() {}
	virtual void printAll() {}
private:
	int x;
	std::string str;
};

class Derived : public Base {
public:
	Derived() {}
	~Derived() {}
	void printAll() {}
private:
	int y;
};


Memory Layout: 
stack :
/----------------------------------------------
int Base::x  
string Base::str (? --> const char*)
Base::_vptr  --> Members type_info Derived, the address of Derived::~Derived(), the address of Derived::printAll()
int Derived::y

text segment:
/----------------------------------------------
Base::Base()  
Base::~Base() 
Base::printAll()
Derived::Derived()  
Derived::~Derived()
Derived::printAll() 
string::string()
string::~string() 
string::length()

/----------------------------------------------
/----------------------------------------------

- **Example**: Memory Layout of an Object With Multiple Inheritances & Virtual Function

class BaseX {
public:
	virtual ~BaseX() {}
	virtual void printX() {}
private: 
	int x;
};

class BaseY {
public:
	virtual ~BaseY() {}
	virtual void printY() {}
private:
	int y;
};

class Derived : public BaseX, public BaseY {
public:
	~Derived() {}
	void printX() {}
	void printY() {}
	void printZ() {}
private:
	int z;
};


Memory Layout: 
stack :
/----------------------------------------------
int BaseX::x 
BaseX::_vptr --> Members type_info Derived, the address of Derived::~Derived(), Derived::printX()
int BaseY::y
BaseY:: _vptr --> Members type_info Derived, the address of Derived::~Derived(), Derived::printY()
int Derived::z

text segment:
/----------------------------------------------
BaseX::~BaseX()
BaseX::printX()
BaseY::~BaseY() 
BaseY::printY()
Derived::~Derived()
Derived::printX()
Derived::printY()
Derived::printZ()

/----------------------------------------------
/----------------------------------------------

- **Example**: Memory Layout of Object Having Virtual Inheritance ???
  - In this case, memory is divided into two regions:
    - an invariant region
    - a shared region

class X { int x; };
class Y : virtual public X { int y; };
class Z : virtual public X { int z; };
class A : public Y, public Z { int a; };


/----------------------------------------------
/----------------------------------------------