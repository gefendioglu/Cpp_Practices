
/----------------------------------------------
/----------------------------------------------

### Type Aliases

-**Example**: Type Aliases
 - type aliases are easier to read 
 - type aliase are compatible with C++ templates types

template <typename T>
using dyn_arr = std::vector<T>;
dyn_arr<int> nums; // equivalent to std::vector<int>

using func_ptr = int (*)(int);


/----------------------------------------------
/----------------------------------------------

### User Defined Literals

-**Example**: User Defined Literals
 - Adding constexpr will serve zero cost run-time performance impact

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

using ull = unsigned long long;
constexpr ull operator"" _KB(ull no){
    return no * 1024;
}
constexpr ull operator"" _MB(ull no){
    return no * (1024_KB);
}

int main() {

    std::cout << 1_KB << "\n";
    std::cout << 5_MB << "\n";
}

/----------------------------------------------
/----------------------------------------------

### Uniform initialization & Non-static member initialization

-**Example**: Uniform initialization & Non-static member initialization

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

class demo {
public:
    demo(uint32_t ival, bool bval, std::string sval, float fval) : m_ival{ ival }, m_bval{ bval }, m_sval{ sval },
        m_fval{ m_fval } {}
private:
    // non-static member initialization
    uint32_t m_ival = 0;
    bool m_bval = false;
    std::string m_sval = "";
    float m_fval = 0.0;
};

int main() {
    // uniform initialization
    demo obj{ 123, true, "lol", 1.1 };
    return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

### Forward Declaration

-**Example**: Forward Declaration

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

// Forward Declaration for class A
class A;

class B {
public:
	void setData(int mdata)	{
		mx = mdata;
	}

	// Forward declaration is required for the parameters of sum func. 
	friend int sum(const A&, const B&);
private:
	int mx;
};

class A {
public:
	void setData(int mdata)	{
		my = mdata;
	}
	friend int sum(const A&, const B&);
private: 
	int my;
};

int sum(const A& m, const B& n){
	return (m.my + n.mx);
}

int main(){

	B b;
	A a;
	
	a.setData(5);
	b.setData(4);
	std::cout << "The sum is : " << sum(a, b);
	// The sum is : 9
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

### Initializer List (std::initializer_list) 

-**Example**: Initializer List

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 
#include<vector>
#include<tuple> 
#include<set> 
#include<list> 
#include<deque> 
#include<array> 
#include<stack> 
#include<queue> 

int main() {

	std::pair<int, int> ipair = { 1, 2 };
	std::tuple<int, int> ituple = { 1, 2 };
	std::vector<int> ivec = { 1, 2, 3, 4, 5 };
	std::set<int> iset = { 1, 2, 3, 4, 5 };
	std::list<int> ilist = { 1, 2, 3, 4, 5 };
	std::deque<int> ideque = { 1, 2, 3, 4, 5 };
	std::array<int, 5> iarray = { 1, 2, 3, 4, 5 };

	// Initializer list is not available for adapters
	std::stack<int> istack = {1, 2, 3, 4, 5}; // NOT OK
	std::queue<int> iqueue = {1, 2, 3, 4, 5}; // NOT OK
	std::priority_queue<int> ipq = {1, 2, 3, 4, 5}; // NOT OK
}

/----------------------------------------------
/----------------------------------------------

## Inline Functions

- Inline functions and inlined functions are different terms
- Implicitly inline functions can be defined in class definition directly. If the function is defined in source file as always, then it is not an inline function. 
- ODR idiom is not violated by the use of inline specifier 
- Constexpr functions are implicitly inlined functions. 
- Both non-static const member functions and non-static non-const member functions can be defined as inlined functions.
- Static member functions can also be defined as inlined function
- Inline functions should be preferred to use for the small and frequently called functions.
- Inline functions are very useful in terms of code optimization. The settings shall be use to set the using level of inline functions.  

/----------------------------------------------
/----------------------------------------------

- **Example** : Inline functions in class definition

class MyClass {
public:
	//Inline function without "inline" specifier
	int func(int val) {
		return val * val;
	}

	int foo(int val);

	//Inline static member function
	static int sfunc(int num1, int num2) {
		return num1 + num2;
	}

	//Inline friend function
	friend int ffunc(int x) {
		//...
		return 1;
	}
}

//Implicitly inlined function 
constexpr int factorial(int n) {
	return n < 2 ? 1 : factorial(n - 1) * n;
}

/----------------------------------------------
/----------------------------------------------

## Delete Functions 

- The following function types can be deleted using "delete" keyword:
  - global functions
  - class member functions
  - special member functions
    - default constructor
    - copy constructor
    - copy assignment function 
    - move constructor  (added with C++11)
    - move assignment function  (added with C++11)
    - destructor

- Calling a deleted function results in a syntax error.

/----------------------------------------------
/----------------------------------------------

- **Example** : Delete Functions & Function Overloading

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

// all the following functions are overloaded
void func(int x, int y);
void func(int);
void func(double) = delete; // func(double) still exists
void func(int*);
void func(long double);

int main() {

	func(12, 24); // OK, func(int x, int y) is called
	func(2.43);   // NOT OK, func(double) is a deleted function
				  // attempting to reference a deleted func. error
	
	/*
		To be executed to add here !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : How can we provide to call func() function with only int parameter? 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

void func(int);

template<typename T>
void func(T x) = delete;

int main() {
	func(12);	// OK, func(int x) is not deleted
	func(2.43); // NOT OK, for the other types, is deleted 
}

/----------------------------------------------
/----------------------------------------------

- **Example** : "default" keyword

class Data {
public:
	// compiler writes the default constructor
	Data() = default; 
	Data(const Data &) = default; 
	~Data() = default; 
	Data(int x) {std::cout << "Data(int x)\n";}
private:
	std::string ms;
};

/----------------------------------------------
/----------------------------------------------

- **Example** : "mutable" keyword

class Data {
public:
	Data() = default;
	~Data() = default; 
	
	void func()const {
		++counter; // OK, thanks to "mutable" 
	}
	void foo() {
		++counter; 
	}
private:
	mutable int counter = 0; 
};

/----------------------------------------------
/----------------------------------------------

- **Example** :