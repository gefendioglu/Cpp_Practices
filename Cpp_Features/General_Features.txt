
/----------------------------------------------
/----------------------------------------------

### Type Aliases

-**Example**: Type Aliases
 - type aliases are easier to read 
 - type aliase are compatible with C++ templates types

template <typename T>
using dyn_arr = std::vector<T>;
dyn_arr<int> nums; // equivalent to std::vector<int>

using func_ptr = int (*)(int);


/----------------------------------------------
/----------------------------------------------

### User Defined Literals

-**Example**: User Defined Literals
 - Adding constexpr will serve zero cost run-time performance impact

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

using ull = unsigned long long;
constexpr ull operator"" _KB(ull no){
    return no * 1024;
}
constexpr ull operator"" _MB(ull no){
    return no * (1024_KB);
}

int main() {

    std::cout << 1_KB << "\n";
    std::cout << 5_MB << "\n";
}

/----------------------------------------------
/----------------------------------------------

### Initializer List (std::initializer_list) 

-**Example**: Initializer List

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 
#include<vector>
#include<tuple> 
#include<set> 
#include<list> 
#include<deque> 
#include<array> 
#include<stack> 
#include<queue> 

int main() {

	std::pair<int, int> ipair = { 1, 2 };
	std::tuple<int, int> ituple = { 1, 2 };
	std::vector<int> ivec = { 1, 2, 3, 4, 5 };
	std::set<int> iset = { 1, 2, 3, 4, 5 };
	std::list<int> ilist = { 1, 2, 3, 4, 5 };
	std::deque<int> ideque = { 1, 2, 3, 4, 5 };
	std::array<int, 5> iarray = { 1, 2, 3, 4, 5 };

	// Initializer list is not available for adapters
	std::stack<int> istack = {1, 2, 3, 4, 5}; // NOT OK
	std::queue<int> iqueue = {1, 2, 3, 4, 5}; // NOT OK
	std::priority_queue<int> ipq = {1, 2, 3, 4, 5}; // NOT OK
}

/----------------------------------------------
/----------------------------------------------

## Inline Functions

- Inline functions and inlined functions are different terms
- Implicitly inline functions can be defined in class definition directly. If the function is defined in source file as always, then it is not an inline function. 
- ODR idiom is not violated by the use of inline specifier 
- Constexpr functions are implicitly inlined functions. 
- Both non-static const member functions and non-static non-const member functions can be defined as inlined functions.
- Static member functions can also be defined as inlined function
- Inline functions should be preferred to use for the small and frequently called functions.
- Inline functions are very useful in terms of code optimization. The settings shall be use to set the using level of inline functions.  

/----------------------------------------------
/----------------------------------------------

- **Example** : Inline functions in class definition

class MyClass {
public:
	//Inline function without "inline" specifier
	int func(int val) {
		return val * val;
	}

	int foo(int val);

	//Inline static member function
	static int sfunc(int num1, int num2) {
		return num1 + num2;
	}

	//Inline friend function
	friend int ffunc(int x) {
		//...
		return 1;
	}
}

//Implicitly inlined function 
constexpr int factorial(int n) {
	return n < 2 ? 1 : factorial(n - 1) * n;
}

/----------------------------------------------
/----------------------------------------------

## Delete Functions 

- The following function types can be deleted using "delete" keyword:
  - global functions
  - class member functions
  - special member functions
    - default constructor
    - copy constructor
    - copy assignment function 
    - move constructor  (added with C++11)
    - move assignment function  (added with C++11)
    - destructor

- Calling a deleted function results in a syntax error.

/----------------------------------------------
/----------------------------------------------

- **Example** : Delete Functions & Function Overloading

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

// all the following functions are overloaded
void func(int x, int y);
void func(int);
void func(double) = delete; // func(double) still exists
void func(int*);
void func(long double);

int main() {

	func(12, 24); // OK, func(int x, int y) is called
	func(2.43);   // NOT OK, func(double) is a deleted function
				  // attempting to reference a deleted func. error
	
	/*
		To be executed to add here !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : How can we provide to call func() function with only int parameter? 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

void func(int);

template<typename T>
void func(T x) = delete;

int main() {
	func(12);	// OK, func(int x) is not deleted
	func(2.43); // NOT OK, for the other types, is deleted 
}

/----------------------------------------------
/----------------------------------------------

- **Example** : "default" keyword

class Data {
public:
	// compiler writes the default constructor
	Data() = default; 
	Data(const Data &) = default; 
	~Data() = default; 
	Data(int x) {std::cout << "Data(int x)\n";}
private:
	std::string ms;
};

/----------------------------------------------
/----------------------------------------------

- **Example** : "mutable" keyword

class Data {
public:
	Data() = default;
	~Data() = default; 
	
	void func()const {
		++counter; // OK, thanks to "mutable" 
		           // normally, it is NOT OK, const func.
	}
	void foo() {
		++counter; 
	}
private:
	mutable int counter = 0; 
};

/----------------------------------------------
/----------------------------------------------

### Temporary Objects:

- After using a temporary object (after evaluating the related row about it), its destructor is called to destroy the object. Each time its constructors are called, whenever a temporary object is created like as a normal object. 

- Sometimes compiler creates a temporary object implicitly, and sometimes user orients the compiler to create a temporary object. 

- Temporary objects are important in terms of efficiency.

- Temporary objects can be linked to  R-Value and const L-Value references. They are not linked to non-const L-Value expressions. 

- Temporary objects are not named, they only include their type names.

- const L-value references can be linked to temporary objects. In that case, the life of temporary objects extended till the end of reference scope (life extension)
  - const Data& ref = Data{ 12 };

- Temporary objects are also used as a return value of a function.

/----------------------------------------------
/----------------------------------------------

- **Example** : Temporary class objects 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data {
public:
	Data(): mx{ 0 }, my{ 0 } {
		std::cout << "Data() default ctor is called...\n";
	};
	Data(int x) : mx{ x }, my{ 0 }{
		std::cout << "Data(int x) ctor is called...\n";
	}
	Data(int x, int y) : mx{ x }, my{ y }{
		std::cout << "Data(int x, int y) ctor is called...\n";
	}
	~Data() {
		std::cout << "~Data() destructor is called...\n";
	}
	void print()const {
		std::cout << "mx : " << mx << " my : " << my << "\n";
	}
private:
	int mx,my;
};

void func(const Data &ref) {
	std::cout << "func(const Data& ref) is called...\n";
}

void func(Data&& ref) {
	std::cout << "func(Data&& ref) is called...\n";
}

int main() {

	// All the followings are temporary objects
	// They can call directly their class member functions
	Data{}.print();        // Data{} --> PR-Value expr.
	Data{ 12 }.print();    // Data{12} --> PR-Value expr.
	Data{ 12,25 }.print(); // Data{12,25} --> PR-Value expr.

	std::cout << "\n";
	const Data& ref = Data{ 12 };
	
	std::cout << "\n";
	Data data;
	func(data); // data is L-Value expr.
				// func(const Data &ref) is called

	std::cout << "\n";
	func(Data(15)); // Data(15) is a  PR-Value expr. 
					// Data(15) can be linked to const L-Val.
					// Data(15) can be linked to R-Val.
					// both func() are viable (?)
	
	/*
		Data() default ctor is called...
		mx : 0 my : 0
		Data(int x) ctor is called...
		mx : 12 my : 0
		Data(int x, int y) ctor is called...
		mx : 12 my : 25
		~Data() destructor is called...

		Data(int x) ctor is called...

		Data() default ctor is called...
		func(const Data& ref) is called...
		
		Data(int x) ctor is called...
		func(Data&& ref) is called...
		~Data() destructor is called...
		~Data() destructor is called...
		~Data() destructor is called...
	*/

	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Temporary objects as function return value and as arguments sent to a function  

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>

void func(const std::string& ref) {
	std::cout << "string : " << ref << "\n";
}

std::string func() {
	char c = 'B';
	//...
	return std::string(100, c); // temp. object 
}

int main(){

	// calling func(const std::string& ref) with temp. object
	func(std::string(100, 'A')); 
	
	std::cout << "\n";
	func();

	return EXIT_SUCCESS;
	/*
		Executed again!!!
	*/
}

/----------------------------------------------
/----------------------------------------------

### Forwarding Reference versus R-Value References 

- They are both represented by && operators.

- Forwarding reference was added to the languagas as a new feature, because of existing move semantics and perfect forwarding. 

/----------------------------------------------
/----------------------------------------------

- **Example** : Forwarding Reference versus R-Value References 

void func(Data&& ref); // func parameter is R-value ref.

template<typename T>
void foo(T&& ref); // foo parameter is not R-value ref.
				   // it is forwarding ref.(universal ref.)

for(auto &&x : data_vec){/**/} // range based for loop --> not R-value ref.
							   // it is forwarding ref.

/----------------------------------------------
/----------------------------------------------

### Copy Elision (Copy Elimination)

- Not to allow copying and moving for compiler optimization. 

- Copy elision is mandatory after C++17.

- If a function takes class type parameters and it is sent temporary objects as arguments for this type of function, copy elision is applied in that case, not calling the copy ctor. Instead, it is calling parameterized ctor directly. 

- **RVO - Return Value Optimization** : This optimization type does not depend on compiler. It is a mandatory feature. If return value of a function is a temporary object, then copy ctor is not called, instead, copying is eliminated and the object created by calling this kind of function. This feature is not controlled by user manually. 

- **NRVO - Named Return Value Optimization** : This type of optimization depends on compiler. It is not a mandatory feature.

/----------------------------------------------
/----------------------------------------------

- **Example** : Copy Elimination, RVO  

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data {
public:
	Data() : mx{ 0 } {
		std::cout << "Data() default ctor is called...this : " << this << "\n";
	}
	Data(int x) : mx{ x } {
		std::cout << "Data(int x) is called...this : " << this << "\n";
	}
	Data(const Data& other) : mx{ other.mx } {
		std::cout << "Data(const Data&) copy ctor is called...this : " << this << "\n";
	}

	~Data() {
		std::cout << "~Data() destructor is called...this : " << this << "\n";
	}
private:
	int mx;
};

void func(Data data) {
	std::cout << "func(Data data) is called...\n";
}

// RVO - Return Value Optimization
// Mandatory Copy Elision (C++17)
// When foo() is called, copy ctor is not called for return value 
Data foo() {
	//...
	return Data{ 20 };
}

int main() {

	std::cout << "main() is started...\n";
	func(Data{});
	// First destructor is called here for Data{}
	std::cout << "main() is still going on...\n\n";

	func(Data{ 10 });  // copy elimination is applied by compiler
					  // not calling copy ctor for Data{10}
					  // calling Data(int x) directly 
					   
	// Second destructor is called here for Data{ 10 }
	std::cout << "main() is still going on...\n\n";

	Data data = foo();
	std::cout << "main() is ended...\n";
	// Third destructor is called here for "data" object

	return EXIT_SUCCESS;
	/*
		To be executed again!!!
	*/
}
/----------------------------------------------
/----------------------------------------------

- **Example** :