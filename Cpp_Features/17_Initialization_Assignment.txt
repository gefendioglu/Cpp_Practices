
## C++ Initialization

/----------------------------------------------
/----------------------------------------------
* Initialization : There are lots of initialization methods in C++
	- copy initialization
	- default initialization
	- zero initialization
* What is indetermined value? 

#include <iostream>

int randomNumber; // default : zero initialization for global variables 

int main() {
	
	// Default initialization and undefined behaviour
	// The value is indetermined value 
	int number; 
	int *ptr; 

	// Copy initialization
	int inum = 10; 
	double dnum = 2.3;
	
	// Zero initializaiton
	static int snum; // default : zero initialization for static local variables
	bool flag = false;
	int* iptr = nullptr;
	long double ldnum = 0;
}

/----------------------------------------------
/----------------------------------------------

* The syntax type of initialization: 
	- copy initialization
	- value initialization (direct initialization)
	- uniform initialization (brace initialization)

- **Example**:

#include <iostream>

struct Data {};

int main() {
	
	// Copy init. 
	int number1 = 10; 

	// Value init. (direct init.)
	int number2(20); 
	int number3{};
	Data myData{};
	int func(); // --> NOT value init.,it is function  declaration
	Data myData(); // --> NOT value init.,it is function  declaration

	// Uniform init. (brace init.)
	int number4{ 30 };
	int primes[]{2,3,5,7,11,13};
	
	int* firstPtr{ primes }; // --> int* secondPtr = &primes[0];
	int* secondPtr = &primes[0];

	std::cout << "Dereferencing firstPtr (*firstPtr): "<< *firstPtr << "\n";
	std::cout << "Dereferencing secondPtr (*secondPtr): "<< *secondPtr << "\n";
}


/----------------------------------------------
/----------------------------------------------
* What are the reasons of using uniform initialization?
	- narrowing conversion
	- most vexing parse : 
	  If the definition has the meaning both variable and function at the same time (because of using paranthesis)

/----------------------------------------------
/----------------------------------------------
- **Example**: Narrowing Conversion 

#include <iostream>

int main() {
	
	// Narrowing conversion: (double --> int) 
	double dnumber = 2.6;
	int copyInit = dnumber;     // Warning : possible loss of data 
	int directInit(dnumber);    // Warning : possible loss of data
	int uniformInit{ dnumber }; // Error : narrowing conversion 

	std::cout << "dnumber: " << dnumber << "\n";
	std::cout << "copyInit: " << copyInit << "\n";
	std::cout << "directInit: " << directInit << "\n";
	std::cout << "uniformInit: " << uniformInit << "\n";
}


/----------------------------------------------
/----------------------------------------------

- **Example**: Most Vexing Parse

#include <iostream>

struct Data {};
struct Stream {
	Stream(Data);
};

int main() {
	
	// Function declaration, not a direct init.
	// warning C4930 :prototyped function not called (was a variable definition intended ? )
	Stream firstStream(Data());
	
	// Uniform initialization, not a function declaration
	Stream secondStream{ Data() }; 
}


## C++ Assignment 
/----------------------------------------------
/----------------------------------------------

- **Example**: Assigning a pointer and reference values 

#include <iostream>

int main() {

	int firstNumber = 10;
	int secondNumber = 99;

	int* ptr = &firstNumber;
	int*& refPointer = ptr;

	std::cout << "ptr : " << ptr << "\n";				// ptr : 00AFFAF8
	std::cout << "refPointer : " << refPointer << "\n"; // refPointer : 00AFFAF8

	*refPointer = 300; // *refPointer --> firstNumber
	std::cout << "firstNumber : " << firstNumber << "\n";  // firstNumber : 300
		
	refPointer = &secondNumber;
	*refPointer = 700; // *refPointer --> secondNumber
	std::cout << "secondNumber : " << secondNumber << "\n"; // secondNumber : 700

}

/----------------------------------------------
/----------------------------------------------

- **Example** Assigning references 

#include <iostream>

int main() {

	int firstNumber = 10;
	int secondNumber = 99;

	int& ref1 = firstNumber;
	int& ref2 = ref1;
	++ref2; 
  
	std::cout << "ref1 : " << ref1 << "\n"; // ref1: 11
	std::cout << "ref2 : " << ref2 << "\n"; // ref2 : 11

}

/----------------------------------------------
/----------------------------------------------