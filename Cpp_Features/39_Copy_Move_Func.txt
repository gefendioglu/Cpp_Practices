
## SPECIAL MEMBER FUNCTIONS  

- Only special member functions can be defaulted using "default" keyword

- Bu fonksyionlarýn kodu belirli koþullar oluþtuðunda compiler tarafýndan yazýlmaktadýr.

- The declaration types of special member functions: 
  - not-declared 
  - user declared 
    - defined by user
	- defaulted by user with "default" keyword
	- deleted by user with "delete" keyword
  - implicitly declared 
	- defaulted by compiler 
	- deleted by compiler 

- The important rule for **implicitly declared and deleted by compiler**: If the compiler writes the special member function of a class according to the rules of the language (implicitly declared & defulted by compiler) and violates the rules of the language at the same time, the compiler will not throw a syntax error. Instead, it deletes the function.

/----------------------------------------------
/----------------------------------------------

- **Example** : Implicitly declared and deleted by compiler

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data {
public:
	// no default ctor for Data class
	Data(int);
};

class Info {
private:
	// default ctor is defaulted, but in private access modifier
	Info();
};

class Member {
public:

private:
	Data data;
	Info info;
};

int main() {

	Member member; // ERROR, because Member() = delete; implicitly
			       // the default ctor of "Member" can not be referenced
				   // it is a deleted function 

	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : not-declared default ctor 

class Data {
public:
	Data(int) {} // Default ctor is not-declared
	~Data() = default; 
private:
	int counter = 0; 
};

int main() {
	Data data;       // ERROR, no default ctor
	Data data{ 10 }; // NOT ERROR,	Data(int) {}
}

/----------------------------------------------
/----------------------------------------------

- **Example** : user declared 

class Data {
public:
	Data();   // user declared, not defined
	Data() {} // user declared, defined
	Data() = default; // user declared, defaulted
	Data() = delete;  // user declared, deleted
private:
	int counter = 0; 
};

/----------------------------------------------
/----------------------------------------------

- **Example** : implicitly declared, deleted default ctor
 
class Data {
public:
	Data(int); 
private:
	int counter = 0; 
};

// Member class default ctor is deleted by compiler
// implicitly declared, deleted
class Member {
private:
	Data mx;
};

int main() {
	Member member; // ERROR
				   // Attempting to reference a deleted function
}

/----------------------------------------------
/----------------------------------------------

## COPY & MOVE CONSTRUCTORS

## Copy Constructors : 

- Ayný türden baþka bir sýnýf nesnesinden kopyalanarak hayata gelen bir nesne için copy ctor çaðrýlmaktadýr.

- The copy ctor written by compiler:
  - public, non-static member function
  - inline member function
  - The declaration of copy ctor --> Data(const Data &ref) = default; 

  - When do we need a copy ctor special member function in a class?
  - T is a class type, x and y are T objects:
    T x = y; --> copy ctor
  - While calling by-value functions 
  - When the return value of a function is a class type, compiler needs to have a temporary object to hold this return value temporarily. In that case, copy ctor is called for this temporary object. 

- Copy constructors are generally written by compiler, not by users. In some specific situations, copy constructors can be coded bu users. 

- If one of copy operations is written by user, move operations are not declared by compiler implicitly. Actually if one of the big three member is written by user, move operations are not declared by compiler implicitly.  

/----------------------------------------------
/----------------------------------------------

- **Example** : When copy constructors shall be written by user?
  - If a class has a pointer type and the copy ctor of this class has been written by compiler, then the pointer types belongs to two different objects Member the same object.
  - If this object is destructed in some way, then the other pointer would be dangling pointer (Members the objects which are no longer exists).

class Member {
public:
	// Membering the same object
	Member(const Member& other) : ptr{other.ptr} {}
private:
	int* ptr;
};

/----------------------------------------------
/----------------------------------------------

- **Example** : Copy ctor and dangling pointer problem 
  - **dangling pointer** is a kind of runtime error
  -**deep copy**--> Instead of copying pointer, it is the copying of the object itself pointed by the copied pointer to a new allocated memory block. 
  - with deep copying, all pointer have their own memory blocks. 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

class String {
public:
	String(const char* pstr) : mlenght{ std::strlen(pstr) } {
		mptr = static_cast<char*>(malloc(mlenght + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::cout << "ctor is called...this : " << this << "\n";
		std::cout << "the address of allocated block : " << (void*)mptr << "\n";
		std::strcpy(mptr, pstr);
	}
	~String() {
		std::cout << "destructor is called...this : " << this << "\n";
		if (mptr)
		{
			std::free(mptr);
		}
		std::cout << "the address of freed block : " << (void*)mptr << "\n";
	}

	size_t length()const {
		return mlenght;
	}

	void print()const {
		std::cout << "[" << mptr << "]" << "\n";
	}

private:
	size_t mlenght;
	char* mptr;
};

void func(String str) {
	std::cout << "func is called...\n";
	str.print();
	std::cout << "func is ended...\n";
}


int main() {

	String s = "Gamze Efendioglu";
	std::cout << "length : " << s.length() << "\n";
	s.print();

	func(s);   
	_getch(); 
	s.print(); // dangling pointer - runtime error
			   // when func is ended, the the temporary object is destroyed
	           // copy ctor is written by compiler
			   // not a deep copy, Membering the same object 

	return EXIT_SUCCESS;

}

/----------------------------------------------
/----------------------------------------------

- **Example** : Calling of copy constructor

class Data {
public:
	Data() : data{ 0 } {}
	Data(const Data& mdata) {}
private:
	int data; 
};

int main() {
	Data data1;
    Data data2 = data1; // copy ctor is called 
    Data data3(data1);  // copy ctor is called 
    Data data4{data1};  // copy ctor is called  
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Copy ctor with temporary objects   

class Data {
public:
	Data() : data{ 0 } {}
	Data(const Data& mdata) {}
	void func(Data mdata);
	~Data() = default;
private:
	int data; 
};

Data gdata;
Data foo() {

	//...
	return gdata; // Temporary object is created here
				  // Copy ctor is called !!!
}

int main() {
	Data kdata;
	kdata.func(kdata); // copy ctor is called here!!!
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy ctor

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class T {};
class U {};
class X {};

class Data {
public:
	Data() = default;
	// copy ctor 
	Data(const Data& other) :mt{ other.mt }, mu{ other.mu }, mx{ other.mx } {}
private:
	T mt;
	U mu;
	X mx;
};


int main() {

	Data data1;
	Data data2 = data1; // copy ctor is called!

	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy ctor 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Member {
public:
	Member() = default;
	Member(const Member& other) :mx{ other.mx }, md{other.md} {
		std::cout << "Member copy ctor is called..." << "\n";
	} 
	void print() const {
		std::cout << "mx : " << mx << "\n";
		std::cout << "md : " << md << "\n";
	}
	void set(const int ival, const double dval) {
		std::cout << "Setting the object data members..." << "\n";
		this->mx = ival;
		this->md = dval;
	}

private:
	int mx = 10;
	double md = 5.4;

};

int main() {

	Member member1;
	member1.print();
	member1.set(20,6.3);
	member1.print();

	Member member2 = member1; // copy ctor is called!
	member2.print();
	member1.set(30, 10.2);
	member2.print();

	return EXIT_SUCCESS;

	/*
		mx : 10
		md : 5.4
		Setting the object data members...
		mx : 20
		md : 6.3
		Member copy ctor is called...
		mx : 20
		md : 6.3
		Setting the object data members...
		mx : 20
		md : 6.3
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Default and Copy Constructors

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <conio.h>

class Member {
public:

	Member() {
		std::cout << "Member() default ctor is called...this : " << this << "\n";
	}

	~Member() {
		std::cout << "~Member() dtor is called...this : " << this << "\n";
	}

	Member(const Member& other){
		std::cout << "Member(const Member& other) copy ctor is called...this : " << this << "\n";
		std::cout << "&other : " << &other << "\n";
	}
};

void funcVal(Member mem) {
	std::cout << "funcVal(Member mem) is called...this : " << &funcVal << "\n";

}

void funcRef(Member &mem) {
	std::cout << "funcRef(Member &mem) is called...this : " << &funcRef << "\n";

}

int main() {
	
	Member m1; // Default ctor
	std::cout << "&m1 : " << &m1 << "\n";

	Member m2 = m1; // Copy ctor is called here !!!
		            // m1 is sent as an argument to copy ctor for m2 object
	std::cout << "&m2 : " << &m2 << "\n";

	funcVal(m2); // Copy ctor is called here !!!
		         // m2 is sent as an argument to copy ctor for func(m2) function

	funcRef(m2); // copy ctor is NOT called !!!
				 // three objects: m1, m2, funcVal temp. object 
				 
	return EXIT_SUCCESS;

	/*
		Member() default ctor is called...this : 0135F82B
		&m1 : 0135F82B
		Member(const Member& other) copy ctor is called...this : 0135F81F
		&other : 0135F82B
		&m2 : 0135F81F
		Member(const Member& other) copy ctor is called...this : 0135F72C
		&other : 0135F81F
		funcVal(Member mem) is called...this : 002D1451
		~Member() dtor is called...this : 0135F72C
		funcRef(Member &mem) is called...this : 002D1456
		~Member() dtor is called...this : 0135F81F
		~Member() dtor is called...this : 0135F82B
	*/
}

/----------------------------------------------
/----------------------------------------------

## Copy Assignment Function:

- Its another name is **Assignment Operator Function**
- non-static, public, inline class member function

- T is a class type:
  T mx;
  T my;
  mx = my; --> copy assign. 
  mx.operator=(my);

- The implementation of copy assignment (Assuming that Data is a class):
  - Data& operator=(const Data &other){}
  - using **copy & swap** idiom (especially for exception handling)

- When do we need to write copy assignment function manually?
  - Whenever it is a necessity to make a deep copy (compilers make a memberwise copy --> the address of objects are copied, instead of objects themselves).

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy assignment

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class T{};
class U{};
class X{};

class Data {
public:
	//copy assignment function (with operator overloading)
	Data &operator=(const Data &other){
		mt = other.mt;
		mu = other.mu;
		mx = other.mx;

		return *this;
	}
	void func() {
		std::cout << "Data::func() is called...this : " << this << "\n";
	}

private:
	T mt;
	U mu;
	X mx;
};

int main() {

	Data data1;
	Data data2;
	data2 = data1; // data2.operator=(data1);
	data2.operator=(data1).func();
	
	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy assignment

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Counter {
public:
	Counter() = default;
	Counter(int x) : mx{ x } {}
	Counter& operator=(const Counter& other){
		std::cout << "Copy assignment is called...this : " << this << "\n";
		std::cout << "&other : " << &other << "\n";

		this->mx = other.mx;
		return *this;
	}
	void func() {
		std::cout << "Counter::func() is called...this : " << this << "\n";
	}
	void print()const {
		std::cout << "mx : " << mx << "\n";
	}
	void set(const int val) {
		this->mx = val;
	}
private:
	int mx;
};

int main() {

	Counter cnt1{10};
	Counter cnt2{20};

	cnt1.print(); // 10
	cnt2.print(); // 20

	cnt2.operator=(cnt1); // cnt2 = cnt1, copy assign. called
	cnt1.print(); // 10
	cnt2.print(); // 10

	(cnt1 = cnt2).print(); // 10
	// copy assign. is called 
	//--> cnt1.operator=(cnt2).print();
	
	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy assignment

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Counter {
public:
	Counter() = default;
	Counter(int x) : mx{ x } {}
	Counter& operator=(const Counter& other){
		std::cout << "Copy assignment is called...this : " << this << "\n";
		std::cout << "&other : " << &other << "\n";
		this->mx = other.mx;
		return *this;
	}
private:
	int mx;
};

int main() {

	Counter cnt1{343};
	Counter cnt2{522};
	
	std::cout << "&cnt1 : " << &cnt1 << "\n";
	std::cout << "&cnt2 : " << &cnt2 << "\n";

	cnt2 = cnt1; // cnt2.operator=(cnt1); 
	
	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The implementation of copy assignment
  - The assignment operator returns the object reference, that's why it is a L-Value expression 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Counter {
public:
	Counter() = default;
	Counter(int x) : mx{ x } {}
	Counter& operator=(const Counter& other){
		std::cout << "Copy assignment is called...this : " << this << "\n";
		this->mx = other.mx;
		return *this;
	}
	void print()const {
		std::cout << "mx : " << mx << "\n";
	}
private:
	int mx;
};

int main() {

	Counter cnt1, cnt2, cnt3, cnt4;
	Counter cnt5{ 115 };

	//cnt1 = cnt2 = cnt3 = cnt4 = cnt5;
	cnt1.operator=(cnt2.operator=( cnt3.operator=( cnt4.operator=(cnt5))));

	cnt1.print();
	cnt2.print();
	cnt3.print();
	cnt4.print();
	cnt5.print();
	
	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Self assignment (unconsciously)

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>
#include <cstdlib>

class String {
public:

	String(const char* pstr) : mlenght{ std::strlen(pstr) } {
		mptr = static_cast<char*>(malloc(mlenght + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::cout << "ctor is called...this : " << this << "\n";
		std::strcpy(mptr, pstr);
	}

	~String() {
		std::cout << "destructor is called...this : " << this << "\n";
		if (mptr)
		{
			std::free(mptr);
		}
	}

	// user declared copy contructor
	String(const String& other) : mlenght{ other.mlenght } {
		std::cout << "Copy ctor is called...this : " << this << "\n";

		// deep copying 
		mptr = static_cast<char*>(malloc(mlenght + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mptr, other.mptr);
	}

	// user declared copy assignment
	String& operator=(const String& other) {
		// control block for self-assignment 
		if (this == &other)
		{
			return *this; // function is ended directly
		}

		std::cout << "Copy assignment is called...this : " << this << "\n";
		// The assigned object must first return its own resource. 
		free(mptr);

		this->mlenght = other.mlenght;

		// deep copying 
		mptr = static_cast<char*>(malloc(mlenght + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mptr, other.mptr);

		return *this;
	}

	void print()const {
		std::cout << "[" << mptr << "]" << "\n";
	}

private:
	size_t mlenght;
	char* mptr;
};

void func(String &str1, String& str2) {
	//...
	str1 = str2;
}

int main() {

	String s2{"Gamze Efendioglu"};
	func(s2, s2); // self-assignment
			      // not a run-time error, because of control blocks in copy assignment function 

	return EXIT_SUCCESS;

	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

## BIG THREE

- The following special member functions consist of big three: 
  - Destructor (related to RAII idiom)
  - Copy Ctor
  - Copy Assignment 

- If you need to write destructor to deallocate the allocated memory block for an object (RAII rule) and if copy ctor and copy assignment functions are written by compiler, then memberwise copy is realized. 
  - For deep copying, it is mandatory to write them by user manually (to allocate different memory blocks for copied objects). 
  - Instead of deep copying, sometimes it is required to delete copy ctor and copy assignment functions (using delete keyword).
    - If these functions are in the private access specifier, they can not be assumed that they are deleted. Because, the other members of the same class can reach end use these functions, has the capability of copying. 

- RAII Idiom (to prevent resource leak): 
  - Resource Acquisition Is Initialization or RAII, is a C++ programming technique which binds the life cycle of a resource that must be acquired before use to the lifetime of an object (resource allocation examples: allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connection—anything that exists in limited supply, etc.).
  - RAII guarantees that all resources are released when the lifetime of their controlling object ends, in reverse order of acquisition.

- If one of the big three member is written by user, move operations are not declared by compiler implicitly.  

/----------------------------------------------
/----------------------------------------------

## BIG FIVE (using instead of Big Three with modern Cpp - C++11)

- The following special member functions consist of big five: 
  - Destructor (related to RAII idiom)
  - Copy Ctor
  - Copy Assignment 
  - Move Ctor
  - Move Assignment

/----------------------------------------------
/----------------------------------------------

- **Example** : Not copyable class object

class Data {
public:
	Data() = default;
	// not copyable
	Data(const Data&) = delete;
	Data& operator=(const Data&) = delete;
private:
};

int main() {

	Data data1, data2;
	Data data3 = data1; // ERROR, copy ctor is deleted func. 
	data1 = data2; // ERROR, copy assign. is a deleted func.  
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

## Move Constructors (with C++11): 

- **Persistent Object**: If an object is a L-Value expression, then it is persistent object. In that case, the resources of these kind of objects shall not be stolen.
  - **copy ctor** is called for persistent objects 

- **Non-Persistent Object**: If an object is a R-Value expression (PR-Value or X-Value), then it is non-persistent object. In that case, the resources of these kind of objects can be stolen. Cause, these objects are not going to be used in the remaining part of the program. 
  - **move ctor** is called for non-persistent objects 
 
## Move Assignment (with C++11): 

- The implementation of move assignment (non-static, public, inline): 
  - Data& operator=(Data&&); 

- std::move() function is not moving an object, it is casting the object's type to R-Value reference type 

- The important section of the following book: 
  - Scott Meyers - Effective Modern C++
    - Item 23: Understand std::move and std::forward.
	- Item 17: Understand special member function generation.
	- " Generated special member functions are implicitly public and inline, and they’re non-virtual unless the function is a destructor in a derived class inheriting from a base class with a virtual destructor. In that case, the compiler-generated destructor for the derived class is also virtual. "

- "Move operations are generated only for classes lacking explicitly declared **move operations**, **copy operations**, and a **destructor**." - Scott Meyers

- If one of move operations is written by user, copy operations are deleted implicitly. 

/----------------------------------------------
/----------------------------------------------

- **Example** : R-Value and L-Value References with functions  
  - R Value References were added to the language to allow the objects to be moved to other objects. 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data {
public:
	Data() = default;
private:
};

// const L-Value Reference
// viable for both R-Value and L-Value calling 
void func(const Data&) {
	std::cout << "func(const Data &) is called...\n";
}

// R-Value Reference
// viable only R-Value calling
// when calling with R-Value, this function is called according to function overload resolution rules
void func(Data&&) {
	std::cout << "func(Data&&) is called...\n";
}

int main() {

	Data data;
	func(data);   // func(const Data &) is called...
	func(Data{}); // func(Data&&) is called...
				  // Data{} --> temp. object, PR-Value Expr.

	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : R-Value and L-Value References with functions 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data {
public:
	Data() = default;
	Data(const Data&); // copy ctor 
	Data(Data&&);      // move ctor 
private:
};

// L-Value Reference Parameter
void func(const Data& ref) {
	std::cout << "func(const Data& ref) is called...\n";
}

// R-Value Reference Parameter
void func(Data&& ref) {
	std::cout << "func(Data&& ref) is called...\n";
}

int main() {

	Data data1;
	func(data1); // L-Value ref.
				 // func(const Data& ref) is called...
	func(static_cast<Data&&>(data1)); // R-Value ref.
									  // func(Data&& ref) is called...
	func(std::move(data1)); // R-Value ref.
							// func(Data&& ref) is called...
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : R-Value and L-Value References with functions called in other functions

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class Data{
public:
	Data() = default;
};

void func(Data&& ref) {
	std::cout << "func(Data&& ref) is called...\n";
}

void func(const Data& ref) {
	std::cout << "func(const Data& ref) is called...\n";
}

void foo(const Data& ref){
	func(ref);
}

void foo(Data&& ref) {
	func(std::move(ref));
}

int main(){

	Data data;
	foo(data);   // func(const Data& ref) is called... 
	foo(Data{}); // func(Data&& ref) is called...

	return EXIT_SUCCESS;
}


/----------------------------------------------
/----------------------------------------------

- **Example** : Move operations (move ctor, move assignment) 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class T {};
class U {};
class X {};

class Data {
public:
	Data() = default;

	// copy constructor
	Data(const Data& other): mt{ other.mt }, mu{other.mu }, mx{ other.mx } {
		std::cout << "copy ctor is called...\n";
	}

	// move constructor
	Data(Data&& other) : mt{ std::move(other.mt) }, mu{ std::move(other.mu) }, mx{std::move(other.mx)} {
		std::cout << "move ctor is called...\n";
	}

	// move assignment 
	Data& operator=(Data&& other){

		std::cout << "move assignment is called...\n";
		this->mt = std::move(other.mt);
		this->mu = std::move(other.mu);
		this->mx = std::move(other.mx);

		return *this;
	}

private:
	T mt;
	U mu;
	X mx;
};

int main() {

	Data data1;
	Data data2{ data1 }; // data1 is a L-Value expr.
						 // copy ctor is called...

	Data data3{ std::move(data1) }; //std::move(data1) is a R-Value expr.
								    // move ctor is called...
									// data1 resource is stolen!!
	Data data4;
	data4 = std::move(data2); // move assignment is called...
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Move and copy operations in a user defined String class
  - Copy ctor and copy assignment implementations without dangling pointer problem by the help of user declared copy constructor.
  - Whenever a need comes out to allocate memory block (if there is an in-class pointer), the copy ctor of this class shall be declared by user.

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <conio.h>

class String {
public:
	// there is no default constructor 
	String(const char* pstr) : mlength{ std::strlen(pstr) } {
		mptr = static_cast<char*>(malloc(mlength + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::cout << "ctor is called...this : " << this << "\n";
		std::cout << "the address of allocated block : " << (void*)mptr << "\n";
		std::strcpy(mptr, pstr);
	}

	~String() {
		std::cout << "destructor is called...this : " << this << "\n";
		if (mptr)
		{
			std::free(mptr);
		}
		std::cout << "the address of freed block : " << (void*)mptr << "\n";
	}

	// user declared copy contructor
	String(const String& other) : mlength{other.mlength } {
		std::cout << "Copy ctor is called...this : " << this << "\n";
		
		// deep copying 
		mptr = static_cast<char*>(malloc(mlength + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::cout << "the address of allocated block : " << (void*)mptr << "\n";
		std::cout << "other.mptr : " << (void*)other.mptr << "\n";
		std::strcpy(mptr, other.mptr);
	}

	// user declared copy assignment
	String& operator=(const String& other) {
		// if the object is assigned to itself
		// if the argument address and the address of object calling this function 
		if (this == &other)
		{
			return *this; // function is ended directly
		}

		std::cout << "Copy assignment is called...this : " << this << "\n";
		// The assigned object must first return its own resource. 
		free(mptr);

		this->mlength = other.mlength;
		
		// deep copying 
		mptr = static_cast<char*>(malloc(mlength + 1));
		if (!mptr)
		{
			std::cerr << "not enough memory...\n";
			std::exit(EXIT_FAILURE);
		}
		std::cout << "the address of allocated block : " << (void*)mptr << "\n";
		std::cout << "other.mptr : " << (void*)other.mptr << "\n";
		std::strcpy(mptr, other.mptr);

		return *this;
	}

	// user declared move constructor
	String(String&& other) : mlength{ std::move(other.mlength) }, mptr{std::move(other.mptr)} {
		std::cout << "Move ctor is called...this : " << this << "\n";
		other.mptr = nullptr;
	}

	// user declared move assignment 
	String& operator=(String&& other) {
		
		// controlling the self-assginment, like in copy assign. func.  
		if (this == &other) 
			return *this;
		
		std::cout << "Move assignment is called...this : " << this << "\n";
		this->mlength = std::move(other.mlength);
		 
		// firstly the source of mptr is given 
		std::free(mptr);
		// then, the source of other object is stolen
		this->mptr = std::move(other.mptr);
		other.mptr = nullptr;
		
		return *this;
	}

	size_t length()const {
		return mlength;
	}

	void print()const {
		std::cout << "[" << mptr << "]" << "\n";
	}

private:
	size_t mlength;
	char* mptr;
};

void func(String str) {
	std::cout << "func is called...\n";
	str.print();
	std::cout << "func is ended...\n";
}

int main() {

	String s1 = "Gamze Efendioglu";
	s1.print();
	std::cout << "\n\n";
	
	func(s1);  // copy ctor is called !!!
	s1.print(); 
	std::cout << "\n\n";
	
	String s2 = "Mehmet Efendioglu";
	s2.print();
	std::cout << "\n\n";

	s2 = s1;   // copy assignment is called here !!!
	s2.print();
	std::cout << "\n\n";

	s2 = s2; // self-assignment --> results in run-time error
			 // there should be a control in copy assignment
	std::cout << "\n\n";

	String s3{ "Hakan" }, s4{ "Sema"};
	String s5 = std::move(s3); // move ctor
	s4 = std::move(s5);        // move assignm.
	std::cout << "\n\n";

	return EXIT_SUCCESS;

	/*
		Executed again !!!
	*/
}

/----------------------------------------------
/----------------------------------------------

### General Notes on Move & Copy Operations: 

- **Rule of Zero Rule**: If the definition of default ctor is sufficient for a class, the writing task for the other special member functions can be assigned to compiler. 

- If the destructor has to be written by user (in the case of existing at least a pointer data member), the other big three members (copy operations) shall be defined by the user too. 

- If big three members are written by user --> it is generally necessary to write the big five member functions (adding move operations)

- If the copy operations of a class are deleted, then move operations are not declared by compiler implicitly. In this case, this kind of classes has the feature of non-copyable and non-movable. 

- Some classes in standard library are not copyable (copy operations are deleted), but movable (move operations are declared & defined). For example, smart pointer class. Smart pointer classes in <memory> library. 
  - Smartpointer(const Smartpointer& ref) = delete;
  - Smartpointer& operator=(const Smartpointer& ref) = delete;
  - Smartpointer(Smartpointer&& ref);
  - Smartpointer& operator=(Smartpointer&& ref);

/----------------------------------------------
/----------------------------------------------

- **Example** : Non-copyable, but movable class example (std::cout)
  - **cout** is a non-copyable, but movable class in **ostream** class

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

void func(std::ostream ost);

int main() {

	func(std::cout); // ERROR, std::cout is non-copyable 
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Non-copyable, but movable class example (smart pointer)

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <memory>

int main() {

	std::unique_ptr<int> uptr1{ new int };
	std::unique_ptr<int> uptr2{ new int };
	
	// ERROR, non-copyable --> copy ctor is deleted!
	std::unique_ptr<int> uptr3{ up2 }; 
	
	// ERROR, non-copyable --> copy assignment is deleted!
	uptr1 = uptr2;

	// NOT ERROR, movable --> move ctor is defined!
	std::unique_ptr<int> uptr4{ std::move(uptr2) };

	// NOT ERROR, movable --> move assignment is defined!
	uptr1 = std::move(uptr2); 

	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : An exceptional case for calling copy ctor instead of move ctor

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

// default ctor, copy ctor is defined
// move ctor is defined in private access modifier
class Data {
public:
	Data(){}
	Data(const Data&){
		std::cout << "copy ctor is called...\n";
	}
private:
	Data(Data&&){}
};

class Member {
	Data data;
};

int main() {

	Member mem1;
	Member mem2{ mem1 }; // copy ctor is called... 
	Member mem3{ std::move(mem1) }; // copy ctor is called...
	
	return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- The following usage is very common in standard library: 

void func(const Data& ref) {
	Data data = ref; // copying ref parameter
}

void func(Data&& ref) {
	Data data = std::move(ref); // moving ref parameter
}

/----------------------------------------------
/----------------------------------------------

- **Example** : The push_back function of vector class is overloaded like mentioned above. 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>

class Data{
public:
	Data() = default;
	Data(const Data& ref) {
		std::cout << "copy ctor is called...\n";
	}
	
	// main aim is to move the object sending as argument
	Data(Data&& ref) {
		std::cout << "move ctor is called...\n";
	}
 
};

int main(){

	std::vector<Data> data_vec;
	data_vec.reserve(100);

	Data data;
	data_vec.push_back(data); // data is L-Value expr.							        // push_back(const Data&) is called
						      // copy ctor is called...

	data_vec.push_back(Data{}); // Data{} is R-Value expr.
								// push_back(Data&&) is called
								// move ctor is called...
	return EXIT_SUCCESS;

	/*
		copy ctor is called...
		move ctor is called...
	*/
}

/----------------------------------------------
/----------------------------------------------

