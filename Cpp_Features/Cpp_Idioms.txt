
## RAII Idiom:

- The same definitions known as: Execute-around object, Resource release is finalization, Scope-bound resource management.

- It aims to guarantee the release of resource(s) at the end of a scope.

- Wrap resource into a class; resource acquired in the constructor immediately after its allocation; and automatically released in the destructor; resource used via an interface of the class.

- RAII guarantees the release of resource at the end of a scope/destruction (no resource leaks).

/----------------------------------------------
/----------------------------------------------

- **Example** : Without applying RAII

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

class resource{
public:
    resource(int x, int y) { 
        std::cout << "Resource is acquired!!!" << "\n"; 
    }
    ~resource() { 
        std::cout << "Resource is destroyed!!!" << "\n"; 
    }
};

int main(){

    resource* ptr = new resource(1, 2);
    int x;

    std::cout << "Enter an integer: ";
    std::cin >> x;

    if (x == 0)
        throw 0; // the function returns early, and ptr won't be deleted, the memory allocated for ptr is leaked !
    if (x < 0)
        return; // the function returns early, and ptr won't be deleted!

    // ptr related codes...

    delete ptr;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Applying RAII

