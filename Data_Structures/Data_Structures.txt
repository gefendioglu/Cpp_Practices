
## LINKED LISTS
- Three basic kinds of linked lists exist: 
  - Singly linked lists
  - Doubly linked lists 
  - Circular linked lists 

## Singly Linked Lists
- Each data element in the list has a link (a pointer or reference) to the element that follows it in the list. 
- The first element in a singly linked list is referred to as the "head" of the list. 
- The last element in such a list is called the "tail".

- When defining classes in C++ for singly linked list, particularly in template form, it’s best to add copy constructors and copy assignment operators so you don’t depend on the compiler- generated versions.

/----------------------------------------------
/----------------------------------------------

- **Example**: Tracking the Head Element (Inserting an element at the front of a list)
  - In C++, the head pointer could also be passed in by reference, or the function could return the new head pointer.

// when return value is a class pointer type
IntElement* IntElement::insertInFront(IntElement** head, int data) {
	IntElement* newElem =new IntElement(data);
	if (!newElem)
		return nullptr;
	newElem->data = data;
	newElem->next = *head;  // The correct version passes in a pointer to the head pointer
	*head = newElem;
	return newElem;
}

// when return value is bool 
bool IntElement::insertInFront(IntElement** head, int data) {
	IntElement* newElem =new IntElement(data);
	if (!newElem)
		return false;
	newElem->data = data;
	newElem->next = *head;  // The correct version passes in a pointer to the head pointer
	*head = newElem;
	return true;
}

/----------------------------------------------
/----------------------------------------------

- **Example**: Traversing a List
  - When traversing, you must always check that you haven’t reached the end of the list.
  - Deletion and insertion require a pointer or reference to the element immediately preceding the deletion or insertion location.

IntElement* IntElement::find(IntElement* head, int data) {
	IntElement* elem = head;
	while (elem != nullptr && elem->getData() != data) {
		elem = elem->getNext();
	}
	return elem;
}

/----------------------------------------------
/----------------------------------------------

- **Example**: Inserting and Deleting Elements
  - Any insertion or deletion of elements in the middle of a list requires modification of the previous element’s next pointer or reference.
  - If you’re given only the element to delete (or before which to insert), this requires traversal of the list from the head because there’s no other way to find the preceding element. 
  - Special care must be taken when the element to be deleted is the head of the list.
  - Deletion and insertion require a pointer or reference to the element immediately preceding the deletion or insertion location. 

/----------------------------------------------

- **Example**: First implementation for deleting elements  from a singly linked list

bool IntElement::deleteElement(IntElement** head, IntElement* deleteMe)
{
	IntElement* elem;
	if (!head || !*head || !deleteMe) /* Check for null pointers */
		return false;

	elem = *head;
	if (deleteMe == *head) { /* special case for head */
		*head = elem->next;
		free(deleteMe);
		return true;
	}
	while (elem) {
		if (elem->next == deleteMe) {
			/* elem is element preceding deleteMe */
			elem->next = deleteMe->next;
			free(deleteMe);
			return true;
		}
		elem = elem->next;
	}
	/* deleteMe not found */
	return false;
}

/----------------------------------------------

- **Example**: Second implementation for deleting elements from a singly linked list 

bool IntElement::deleteElement_I(IntElement** npp, IntElement* deleteMe) {

	IntElement* elem;

	if (!npp || !*npp || !deleteMe) /* Check for null pointers */
		return false;

	while (*npp) {
		if (*npp == deleteMe) {
			/* npp points to head pointer (if deleteMe is first element) or to next pointer within preceding element */
			*npp = deleteMe->next;
			free(deleteMe);
			return true;
		}
		/* Iterating for the next list element */
		npp = &((*npp)->next);
	}
	/* deleteMe not found */
	return false;
}


/----------------------------------------------
/----------------------------------------------

- **Example** : Deleting all list elements
  - Performing deletions raises another issue in languages without garbage collection, like C or C++. 
  - Do you advance the pointer first or free the element first? 
    - If you advance the pointer first, then the freeing is impossible because you overwrote the pointer to the element to be freed. 
	- If you free the element first, advancing the pointer is impossible, because it involves reading the next pointer in the element that was just freed.
	- The solution is to use two pointers !!!


void IntElement::deleteList(IntElement** head)
{
	// First pointer points the first element of list
	IntElement* deleteMe = *head;

	while (deleteMe) {
		// Second pointer points the next element of the element which will be deleted
		IntElement* next = deleteMe->next;
		// delete the element
		free(deleteMe);
		deleteMe = next;
	}
	*head = nullptr;
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Singly LÝnked List Implementation (not using templates)
  - Client Code shall be written !!!

#include <iostream>
#include <array>

// A singly linked list in C++
class IntElement {
public:
	IntElement(const int &value) :next{ nullptr }, data{ value }{}
	~IntElement() {}

	// getter functions
	IntElement* getNext()const { return next; }
	const int& getData()const { return data; }

	// setter functions
	void setNext(IntElement* ptr) { next = ptr; }
	void setData(const int& value) { data = value; }

	// other linked list functions
	IntElement* insertInFront(IntElement** head, int data);
	IntElement* find(IntElement* head, int data);
	bool deleteElement(IntElement** head, IntElement* deleteMe);
	bool deleteElement_I(IntElement** head, IntElement* deleteMe);
	void deleteList(IntElement** head);

	//operator overloading function ???
	//std::ostream& operator<<(std::ostream& str, IntElement* ptr);

private:
	IntElement* next;
	int data;
};

IntElement* IntElement::insertInFront(IntElement** head, int data) {
	IntElement* newElem =new IntElement(data);
	if (!newElem)
		return nullptr;
	newElem->data = data;
	newElem->next = *head;  // The correct version passes in a pointer to the head pointer
	*head = newElem;
	return newElem;
}

IntElement* IntElement::find(IntElement* head, int data) {
	IntElement* elem = head;
	while (elem != nullptr && elem->getData() != data) {
		elem = elem->getNext();
	}
	return elem;
}

bool IntElement::deleteElement(IntElement** npp, IntElement* deleteMe) {

	IntElement* elem;

	if (!npp || !*npp || !deleteMe) /* Check for null pointers */
		return false;

	while (*npp) {
		if (*npp == deleteMe) {
			/* npp points to head pointer (if deleteMe is first element) or to next pointer within preceding element */
			*npp = deleteMe->next;
			free(deleteMe);
			return true;
		}
		/* Iterating for the next list element */
		npp = &((*npp)->next);
	}
	/* deleteMe not found */
	return false;
}

void IntElement::deleteList(IntElement** head)
{
	// First pointer points the first element of list
	IntElement* deleteMe = *head;

	while (deleteMe) {
		// Second pointer points the next element of the element which will be deleted
		IntElement* next = deleteMe->next;
		// delete the element
		free(deleteMe);
		deleteMe = next;
	}
	*head = nullptr;
}

int main()
{
	IntElement ilist(0);
	//ilist.insertInFront(&ilist.getNext(), ilist.getData());
	//IntElement *ptr = ilist.find(ilist.getNext(), 6);
	//std::cout << *ptr << "\n";
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Stack Implementation (TO BE COMPLETED)
  - The createStack function sets the stack pointer to NULL and returns success
  - The push function allocates the new element, checks for failure, sets the data of the new element, places it at the top of the stack, and adjusts the stack pointer.
  - The pop operation checks that the stack isn’t empty, fetches the data from the top element, adjusts the stack pointer, and frees the element that is no longer on the stack. 
  - Although deleteStack could call pop repeatedly, it’s more efficient to simply traverse the data structure, freeing as you go. Don’t forget that you need a temporary pointer to hold the address of the next element while you free the current one.
  - The createStack and deleteStack functions become the constructor and destructor, respectively.
  - A more complete C++ implementation should include a copy constructor and assignment operator, because the default versions created by the compiler could lead to multiple deletes of the same Element due to inadvertent sharing of elements between copies of a Stack.



/----------------------------------------------
/----------------------------------------------

## TREES and GRAPHS

- A tree is made up of nodes (data elements) with zero, one, or several references (or pointers) to other nodes. Each node has only one other node referencing it.
- In object-oriented languages you usually define a class for the common parts of a node and one or more subclasses for the data held by a node.

## Binary Tree



/----------------------------------------------
/----------------------------------------------

- **Example**: Binary Search Tree / Searching an element with class and class member function

#include <iostream>
#include <array>

// Binary Tree
class Node {
public:

	Node(int v) : left{ nullptr }, right{ nullptr }, value{v}{}
	
	//getter functions
	Node* getLeft() const { return left; }
	Node* getRight() const { return right; }
	int getValue() const { return value; }

	// setter functions
	void setLeft(Node* left) { this->left = left; }
	void setRight(Node* right) { this->right = right; }
	
	// tree functions
	Node* findNode(Node* root, int value);
	Node* findNode_rcrsv(Node* root, int value);

private:
	Node* left;
	Node* right;
	int value;
};

// Searching an element in a binary search tree
Node* Node::findNode(Node* root, int value) {
    // This process continues until you reach a null reference (the end of a tree)
	while (root != nullptr) {
		int curVal = root->getValue();
		if (curVal == value) break;
		if (curVal < value) {
			root = root->getRight();
		}
		else { // curVal > value
			root = root->getLeft();
		}
	}
	return root;
}

// Searching an element in a binary search tree with a recursive function
Node* Node::findNode_rcrsv(Node* root, int value) {
	if (root == nullptr) return nullptr;
	int curVal = root->getValue();
	if (curVal == value) return root;
	if (curVal < value) { 
		return findNode_rcrsv(root->getRight(), value);	
	}
	else { // curVal > value
		return findNode_rcrsv(root->getLeft(), value);
	}

}


int main()
{
	// Making a binary search tree with available values
	Node* root = new Node(5);
	Node* left = new Node(3);
	Node* right = new Node(10);

	root->setLeft(left);
	root->setRight(right);

	Node* left_left = new Node(1);
	Node* left_right = new Node(4);

	left->setLeft(left_left);
	left->setRight(left_right);

	Node* right_left = new Node(7);
	Node* right_right = new Node(12);

	right->setLeft(right_left);
	right->setRight(right_right);

	Node* searched = root->findNode(root, 7);
	std::cout << "value address: " << searched << "\n"; // value address: 0170F028
}

/----------------------------------------------
/----------------------------------------------

- **Example** : Binary Search Tree / Searching an element with structure and recursion function

#include <iostream>

// Binary Tree
struct node
{
	int data;
	struct node* left;
	struct node* right;
	node(int value) {
		data = value;
		left = nullptr;
		right = nullptr;
	}
};

// Searching an element in binary search tree with recursion function
node* search(node* root, int key)
{
	// Base Cases: root is null or key is present at root data
	if (root == NULL || root->data == key)
		return root;

	// Key is greater than root's data 
	if (root->data < key)
		return search(root->right, key);

	// Key is smaller than root's data 
	return search(root->left, key);
}

int main()
{
	// Making a binary search tree with available values
	node* root = new node(5);
	root->left = new node(3);
	root->right = new node(10);
	root->left->left = new node(1);
	root->left->right = new node(4);
	root->right->left = new node(7);
	root->right->right = new node(12);

	node* searched = search(root, 7);
	std::cout << "value address: " << searched << "\n"; // value address: 00D621C8

}

/----------------------------------------------
/----------------------------------------------