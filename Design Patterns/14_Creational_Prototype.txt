
## Prototype Desing Patterns (Clone Pattern)

/----------------------------------------------
/----------------------------------------------

- **Example**: The problem to use Prototype Design Pattern

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

class Office {
public:
    Office(std::string street, std::string city, int32_t cubical)
        :m_street(street), m_city(city), m_cubical(cubical) {}

private:
    std::string m_street;
    std::string m_city;
    int32_t m_cubical;
};

class Employee {
public:
    Employee(std::string name, Office office) :m_name(name), m_office(office) {}

private:
    std::string m_name;
    Office m_office;
};

int main() {

    Employee john{ "John Doe", Office{"123 East Dr", "London", 123} };
    Employee jane{ "Jane Doe", Office{"123 East Dr", "London", 124} };
    Employee jack{ "jack Doe", Office{"123 ORR", "Bangaluru", 300} };

    return EXIT_SUCCESS;
}


/----------------------------------------------
/----------------------------------------------

- **Example**: Prototype Design Pattern Solution


#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

class Office {
public:
    Office(std::string street, std::string city, int32_t cubical)
        :m_street(street), m_city(city), m_cubical(cubical) {}

private:
    std::string m_street;
    std::string m_city;
    int32_t m_cubical;
};

class Employee {
public:
    Employee(std::string name, Office office) :m_name(name), m_office(office) {}

private:
    std::string m_name;
    Office m_office;
};

static Office LondonOffice{ "123 East Dr", "London", 123 };
static Office BangaluruOffice{ "RMZ Ecoworld ORR", "London", 123 };

int main() {

    Employee john{ "John Doe", LondonOffice };
    Employee jane{ "Jane Doe", LondonOffice };
    Employee jack{ "jack Doe", BangaluruOffice };

    return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------

- **Example**: Prototype Factory Design Pattern Solution

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

struct Office {
    std::string m_street;
    std::string  m_city;
    int32_t m_cubical;
};

class Employee {
public:

    // Copy constructor
    Employee(const Employee& employee) : m_name{ employee.m_name }, m_office{ new Office{*employee.m_office} }
    { }

    // Copy assignment
    Employee& operator=(const Employee& rhs) {
        if (this == &rhs) return *this;
        m_name = rhs.m_name;
        m_office = new Office{ *rhs.m_office };
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const Employee& employee) {
        return os << employee.m_name 
            << " works at " << employee.m_office->m_street 
            << " " << employee.m_office->m_city 
            << " seats @" << employee.m_office->m_cubical;
    }

private:
    std::string m_name;
    Office* m_office;

    // Private constructor
    // Direct instance can not be created except for "class EmployeeFactory"
    Employee(std::string name, Office* office) : m_name(name), m_office(office) {}
    friend class EmployeeFactory;
};

class EmployeeFactory {
public:

    static std::unique_ptr<Employee> NewMainOfficeEmployee(std::string name, int32_t cubical) {
        return NewEmployee(name, cubical, main);
    }
    static std::unique_ptr<Employee> NewAuxOfficeEmployee(std::string name, int32_t cubical) {
        return NewEmployee(name, cubical, aux);
    }

private:

    static Employee main;
    static Employee aux;
    static std::unique_ptr<Employee> NewEmployee(std::string name, int32_t cubical, Employee& proto) {
        auto employee = std::make_unique<Employee>(proto);
        employee->m_name = name;
        employee->m_office->m_cubical = cubical;
        return employee;
    }
};

// Static Member Initialization 
Employee EmployeeFactory::main{ "", new Office{"123 East Dr", "London", 123} };
Employee EmployeeFactory::aux{ "", new Office{"RMZ Ecoworld ORR", "London", 123} };

int main() {

    auto jane = EmployeeFactory::NewMainOfficeEmployee("Jane Doe", 125);
    auto jack = EmployeeFactory::NewAuxOfficeEmployee("Jack Doe", 123);
    std::cout << *jane << "\n" << *jack << "\n";

    return EXIT_SUCCESS;

    /*
        Jane Doe works at 123 East Dr London seats @125
        Jack Doe works at RMZ Ecoworld ORR London seats @123
    */
}


/----------------------------------------------
/----------------------------------------------

- **Example**: The problem about not have virtual constructor 
  -	C++ has the support of polymorphic object destruction using it’s base class’s virtual destructor. 
  -	Equivalent support for creation and copying of objects is missing as С++ doesn’t support virtual constructor & virtual copy constructors.

class animal {
public:
    virtual ~animal() { std::cout << "~animal\n"; }
};

class dog : public animal {
public:
    ~dog() { std::cout << "~dog\n"; }
};

class cat : public animal {
public:
    ~cat() { std::cout << "~cat\n"; }
};

// Not sure whether dog would be passed here or cat
void who_am_i(animal* who) { 
    // How to `create` the object of same type i.e. pointed by who ?
    // How to `copy` object of same type i.e. pointed by who ?
    delete who; // you can delete appropriate object pointed by who, thanks to virtual destructor
}

int main() {
    
    animal* animal_dog = new dog();
    animal* animal_cat = new cat();
    
    who_am_i(animal_dog); 
    who_am_i(animal_cat); 

    /*
        ~dog
        ~animal
        ~cat
        ~animal
    */

    return 0;
}


/----------------------------------------------
/----------------------------------------------

- **Example**: Leveraging Prototype Design Pattern to Implement Virtual Copy Constructor (through create() and clone() functions)

class animal {
public:
    virtual ~animal() = default;
    virtual std::unique_ptr<animal> create() = 0;
    virtual std::unique_ptr<animal> clone() = 0;
 };

class dog :public animal {
public:
    // Derived (dog) --> Base (animal) - upcasting
    std::unique_ptr<animal> create() { 
        std::cout << "creating dog object" << "\n";
        return std::make_unique<dog>(); 
        
    }

    std::unique_ptr<animal> clone() { 
        std::cout << "cloning dog object" << "\n";
        return std::make_unique<dog>(*this); 
    }
};

class cat : public animal {
public:
    // Derived (cat) --> Base (animal) - upcasting
    std::unique_ptr<animal> create() {
        std::cout << "creating cat object" << "\n";
        return std::make_unique<cat>(); 
    }

    std::unique_ptr<animal> clone() { 
        std::cout << "cloning cat object" << "\n";
        return std::make_unique<cat>(*this); 
    }
};

void who_am_i(animal* who) { 
    auto new_who = who->create(); 
    auto duplicate_who = who->clone(); 
    delete who; 
}

int main() {
    
    animal* animal_dog = new dog();
    animal* animal_cat = new cat();
    
    who_am_i(animal_dog); 
    who_am_i(animal_cat); 

    /*
        creating dog object
        cloning dog object
        creating cat object
        cloning cat object
    */

    return 0;
}