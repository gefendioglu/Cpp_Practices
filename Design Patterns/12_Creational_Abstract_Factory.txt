
## Abstract Factory Design Pattern 

- Why Abstract Factory Design Pattern is needed to use?
  - C++ has the support of polymorphic object destruction using it’s base class’s virtual destructor. However, equivalent support for creation & copying of objects does not exist in C++ virtual constructor & virtual copy constructors.

- This design pattern is applied by delegating the act of creation & copying the object to the derived class through the use of pure virtual functions (polymorphic functions).

- Liskov’s Substitution Principle(LSP) is applied with the use of Abstract Factory design pattern.

/----------------------------------------------
/----------------------------------------------

- **Example**: The Problem
  
#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 

class Point {
public:
    virtual ~Point() {
        std::cout << "Point::~Point()\n";
    }
};

class Point2D :public Point {
public:
    ~Point2D() {
        std::cout << "Point::~Point2D()\n";
    }
};

class Point3D : public Point {
public:
    ~Point3D() {
        std::cout << "Point::~Point3D()\n";
    }
};

void create_point() {
    // Not sure which object class would be passed here ("Point2D" or "Point3D")
    // Point3D* ptr3d = new Point3D();
    // Point2D* ptr2d = new Point2D();
    Point* point = new Point();
    delete point;
}

int main() {

    create_point();

    return EXIT_SUCCESS;
    /*
        Point::~Point()
    */
}

/----------------------------------------------
/----------------------------------------------

- **Example**: Abstract Factory Design Pattern (CREATIONAL_ABSTRACT_FACTORY)

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 
#include<memory>

class Point {
public:
    Point(int x, int y) : m_x(x), m_y(y) {}
    virtual ~Point() = default;

    // Like virtual constructor
    virtual std::unique_ptr<Point> create() = 0;

    // Like virtual copy constructor
    virtual std::unique_ptr<Point> clone() = 0;

    friend std::ostream& operator<<(std::ostream& os, const Point& obj) {
        return os << "x: " << obj.m_x << " y: " << obj.m_y;
    }

private:
    int   m_x;
    int   m_y;
};

class Point2D : public Point {
public:
    std::unique_ptr<Point> create() { 
        // Derived --> Base (upcasting)
        // Point2D --> Point
        return std::make_unique<Point2D>(); 
    }

    std::unique_ptr<Point> clone() { 
        return std::make_unique<Point2D>(*this); 
    }
};

class Point3D : public Point {
public:
    // Derived --> Base (upcasting)
    // Point3D --> Point
    std::unique_ptr<Point> create() { 
        return std::make_unique<Point3D>(); 
    }

    std::unique_ptr<Point> clone() { 
        return std::make_unique<Point3D>(*this); 
    }
};

void point_func(Point* point) {
    
    // "create" the object of same type i.e. pointed by who ?
    auto new_point = point->create(); 

    // "copy" the object of same type i.e. pointed by who ?
    auto duplicate_point = point->clone();    
    delete point;
}

int main() {

    // TO BE IMPLEMENTED !!!
    return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------


## Functional Factory Design Pattern 

- If it is not necessary to use polymorphic functionality for example in a time-constrained application like an embedded system, functional & lambda functions can be used together to apply factory design pattern.

/----------------------------------------------
/----------------------------------------------

- **Example**: Functional Approach to Factory Design Pattern using Modern C++ (CREATIONAL_FUNCTIONAL_FACTORY)

#define _CRT_SECURE_NO_WARNINGS
#include<iostream> 
#include<memory>
#include<map>
#include<functional>

enum class PointType { Point2D, Point3D };

class Point {
public:
    Point() = default;
    Point(int x, int y) : m_x{ x }, m_y{ y } {}
    virtual ~Point() = default;

    friend std::ostream& operator<<(std::ostream& os, const Point& obj) {
        return os << "x: " << obj.m_x << " y: " << obj.m_y;
    }
private:
    int m_x;
    int m_y;
};

class Point2D : public Point {/* . . . */ };
class Point3D : public Point {/* . . . */ };

class PointFunctionalFactory {
public:
    PointFunctionalFactory() {
        m_factories[PointType::Point2D] = [] { 
            return std::make_unique<Point2D>(); 
        };
        m_factories[PointType::Point3D] = [] { 
            return std::make_unique<Point3D>(); 
        };
    }
    std::unique_ptr<Point> create(PointType type) { 
        return m_factories[type](); 
    }
private:
    std::map<PointType, std::function<std::unique_ptr<Point>() >> m_factories;
};

int main() {

    PointFunctionalFactory pf;
    auto point2D = pf.create(PointType::Point2D);
    std::cout << point2D << "\n"; // The address of point2D
    
    return EXIT_SUCCESS;
}

/----------------------------------------------
/----------------------------------------------


