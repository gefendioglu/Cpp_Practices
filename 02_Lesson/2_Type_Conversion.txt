/----------------------------------------------
/----------------------------------------------

* CPP --> No conversion from arithmetic types to enum types automatically

#include <iostream>

enum Color{White, Gray, Black};

int main() {

	enum Color mycolor = Gray;
	mycolor = (Color)2;
	// mycolor = 2; --> is OK in main.c

	std::cout << "mycolor: " << mycolor << "\n"; // mycolor: 2

}

/----------------------------------------------
/----------------------------------------------
* CPP --> No conversion between different enum types automatically 

#include <iostream>

enum Color{White, Gray, Black};
enum Position{OFF, ON};

int main() {

	enum Color myColor = Gray;// --> Gray : 1
	enum Position myPosition = ON; // --> ON : 0

	myColor = (Color)myPosition;
	// mycolor = myPosition; --> is OK in main.c

	std::cout << "myPosition: " << myPosition << "\n"; // myPosition: 1
	std::cout << "myColor: " << myColor << "\n"; // myColor: 1

}

/----------------------------------------------
/----------------------------------------------

* CPP --> The conversion from enum types to the other types is OK 
		  For example: enum --> int 

#include <iostream>

enum Color{White, Gray, Black};
enum Position{OFF, ON};

int main() {

	enum Color myColor = Black;// --> Gray : 2
	enum Position myPosition = OFF; // --> OFF : 0

	int number1 = myColor;
	int number2 = myPosition;
	std::cout << "number1: " << number1 << "\n"; // number1: 2 --> myColor
	std::cout << "number2: " << number2 << "\n"; // number2: 0 --> myPosition

}

/----------------------------------------------
/----------------------------------------------

* C    --> The conversion from pointer types to arithmetic types is OK 
  C ++ --> No conversion from pointer types to arithmetic types automatically

#include <iostream>

int main() {
	
	int x = 0;
	int* ptr = &x; // int* ptr = x;     --> OK, warning in main.c 
				   // int number = ptr; --> OK, warning in main.c 
}

/----------------------------------------------
/----------------------------------------------

* C++ data conversion types:
	- static_cast
	- const_cast
	- reinterpret_cast
	- dynamic_cast


/----------------------------------------------
/----------------------------------------------

* The type conversion between different address types:
	- The data type and pointer type shall be compatible to each other, C++ --> error
	- The data type and pointer type shall be compatible to each other, C   --> warning

#include <iostream>

int main() {
	
	int x = 10;
	// double* ptr = &x; --> C++ a value of type cannot be used to initialize an entity of type
	// double* ptr = &x; --> C warning C4133 : incompatible types from 'int*' to 'double*'
	double* ptr = (double*)&x;
}

/----------------------------------------------
/----------------------------------------------

* C ++ --> No type conversion between pointer types automatically 
		   T* --> U* (T and U are two different data type)

#include <iostream>

int main() {
	
	int x = 10;
	int* ptr = &x;
}
/----------------------------------------------
/----------------------------------------------

* The data types for addresses: 

#include <iostream>

int main() {
	
	int x = 10;
	// &x --> the data type of x : int*

	int primes[10] = {};
	// &primes --> the data type of primes array : int* (array decay)

	const int cx = 10;
	// &cx --> the data type of cx : const int*

	int const icx = 10;
	// &icx --> the data type of cx : const int* (like the previous one)

	const int cprimes[10] = {};
	// &cprimes --> the data type of cprimes array : const int* 
	
	char name[6] = "gamze";	
	// string literals in C
	// &name --> the data type of name : char* in C

	const char cname[6] = "gamze";	
	// string literals in C++ 
	// &cname --> the data type of cname : const char* in C++ 
}

/----------------------------------------------
/----------------------------------------------

* The type conversion rules for const address types (const int *):

-  C   --> The type conversion from const address data types to non-const address data types is OK.
   C++ --> No type conversion from const address data types to non-const address data types. 
		  const T* --> T* (NOT OK)

-  C   --> The type conversion from non-const address data types to const address data types is OK.
   C++ --> The type conversion from non-const address data types to const address data types is OK.
		  T* --> const T* (OK)

#include <iostream>

int main() {
	
	int x = 10;
	const int *cptr = &x; // T* --> const T* (OK)

	const char* name = "Gamze Efendioglu";
	// char* name = "Gamze Efendioglu"; --> Error in main.cpp, not Error in main.c
	// Error C2440 'initializing': cannot convert from 'const int *' to 'int *'	
}

/----------------------------------------------
/----------------------------------------------

* The type conversion for void pointers:
	- C++ --> T* --> void T* (OK) 
	- C++ --> void T* --> T* (OK)
	  C   --> void T* --> T* (NOT OK)

#include <iostream>

int main() {
	
	int ival = 10;
	unsigned int uval = 20;
	double dval = 5;
	char str[] = "gamze";

	// T* --> void T* (OK) in main.cpp
	void* vptr = &ival; // void pointer 
	vptr = &uval;
	vptr = &dval;
	vptr = str;

	// void T* --> T* (NOT OK) in main.cpp
	// int* iptr = vptr;
	// Error E0144: a value of type "void *" cannot be used to initialize an entity of type "int *
}

/----------------------------------------------
/----------------------------------------------

#include <iostream>
#include <stdlib.h>

int main() {
	size_t n;
	// int* iptr = malloc(n * sizeof(int)); // NOT OK --> 
	int* iptr = (int*)malloc(n * sizeof(int));
}

/----------------------------------------------
/----------------------------------------------

## Type Conversion 

/----------------------------------------------
/----------------------------------------------

- static_cast
  - int ival; 
    static_cast<double>(ival);
- const_cast
- reinterpret_cast
- dynamic_cast

/----------------------------------------------
/----------------------------------------------
- **Example** : C++ Type Conversion

#include <iostream>
#include <ctime>

int main()
{
    int x, y;
    srand(static_cast<unsigned int>(time(nullptr)));
    std::cin >> x >> y;

    static_cast<double>(x) / y;
     
}

/----------------------------------------------
/----------------------------------------------

- **Example** : C Type Conversion Problem

#include <iostream>

int main()
{
    int x = -1; 
    unsigned int y = 1;
    if (x > y)
        std::cout << "True\n"; // return True (why?)
    else
        std::cout << "False\n";
}

/----------------------------------------------
/----------------------------------------------

- **Example** : 

#include <iostream>

int main()
{
    char c = 178; 
    if (c ==178)
        std::cout << "True\n";
    else
        std::cout << "False\n"; // return False  (why?)
}

/----------------------------------------------
/----------------------------------------------

- **Example** : C Type Comversion Problem 

#include <iostream>

char* StrChr(const char* p, int c
) {
	while (*p) {
		if (*p == c)
		{
			return const_cast<char*>(p);
		}
	}
    ++p;
	// warning C4715: 'StrChr': not all control paths return a value
}

int main()
{
	char c = 178;
	// warning C4309: 'initializing': truncation of constant value
	if (c == 178)
		std::cout << "True\n";
	else
		std::cout << "False\n"; // return False 
}

/----------------------------------------------
/----------------------------------------------

- **Example** : If the other type conversion structure is used rather than reinterpret_cast, then it return a syntax error 
  - ++i --> prefix operator shall be preferred instead of postfix operator 

#include <iostream>

int main(){

	double dval = 324.2354;
	unsigned char* p = reinterpret_cast<unsigned char*>(&dval); // OK!!!
	unsigned char* p = const_cast<unsigned char*>(&dval);  // NOT OK!!!
	unsigned char* p = static_cast<unsigned char*>(&dval); // NOT OK!!!
	for (size_t i = 0; i < sizeof(dval); ++i)
	{
		std::cout << p[i] << " ";
	}

}

/----------------------------------------------
/----------------------------------------------

- **Example** : Type Conversion Problems

#include <iostream>

enum Color{Black, White, Green};

int main(){

	Color mycolor{Green};
	mycolor = 3; // ERROR !!!
}

/----------------------------------------------
/----------------------------------------------

#include <iostream>

enum Color{Black, White, Green};

int main(){

	Color mycolor{Green};
	int ival = 2;
	//mycolor = ival; // ERROR !!!
	mycolor = static_cast<Color>(ival); // NOT ERROR !!!
}

/----------------------------------------------
/----------------------------------------------

#include <iostream>
#include <cstdlib>

int main(){

	size_t n = 10000;
	char* p = malloc(n); // ERROR
	char* p = static_cast<char*>(malloc(n)); // NOT ERROR

}

/----------------------------------------------
/----------------------------------------------

- **Example** : Two different conversion can not be realized at the same time

#include <iostream>

int main(){

	const double* ptr = nullptr;
	char* p = const_cast<char*>(ptr);       // ERROR
	char* p = reinterpret_cast<char*>(ptr); // ERROR
	
	// The source of error: 
	// 1 - non-const --> const conversion
	// 2 - double*   --> char* conversion 

	// The solution is to mix both these type conversions: 
	const_cast<char*>(reinterpret_cast<const char*>(ptr)); // OK
	reinterpret_cast<char*>(const_cast<double*>(ptr));     // OK
}

/----------------------------------------------
/----------------------------------------------

